---
title: "Day 3 - Tidyverse"
author: "Geyer Bisschoff"
date: "January, 2018"
output: 
  ioslides_presentation:
    widescreen: true
    toc: true
    toc_float: true
    theme: "flatly"
---


## Introduction
- Day 1 - Getting started
- Day 2 - Functions & Spark
- Day 3 - Tidyverse
- Day 4 - Plotly
- Day 5 - Shiny Introduction
- Day 6 - Reactivity
- Day 7 - Modules
- Day 8 - Shiny Project


# Day 3 - Tidyverse
## Day 3 - Agenda

- select
- filter
- arrange
- mutate
- summarise
- group_by
- %>% (pipe)

```{r,  include=FALSE}
library(tidyverse)
```

## select

It’s not uncommon to get data sets with hundreds or even thousands of variables. In this case, the first challenge is often narrowing in on the variables you’re actually interested in. select() allows you to rapidly zoom in on a useful subset using operations based on the names of the variables.

```{r,eval=FALSE}

select(diamonds, cut, color, carat, price)
select(diamonds, x:z)
select(diamonds, -(x:z))
select(diamonds, starts_with("c"))
select(diamonds, ends_with("e"))
select(diamonds, contains("r"))

```
<strong class="blue2">TIP:</strong> Move sorting variables to the start of the data frame and only keep the important variables. Variables can be renamed at the same time.


## filter
filter() allows you to subset observations based on their values. The first argument is the name of the data frame. The second and subsequent arguments are the expressions that filter the data frame.

```{r,eval=FALSE}
filter(diamonds, cut=="Ideal")
filter(diamonds, cut!="Ideal")
filter(diamonds, carat>=4) # <, >, ==, !=, <=, >=
filter(diamonds, cut=="Ideal" & carat>=4 )
filter(diamonds, cut=="Ideal" | carat>=4 )
filter(diamonds, cut %in% c("Ideal","Premium"))

sqrt(2)^2 == 2
near(sqrt(2)^2, 2)
```

## arrange
arrange() works similarly to filter() except that instead of selecting rows, it changes their order. It takes a data frame and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns.

```{r,eval=FALSE}
arrange(diamonds, cut) #A-Z
arrange(diamonds, desc(cut)) #Z-A

arrange(diamonds, price) #Small to large
arrange(diamonds, desc(cprice)) #Large to small

arrange(diamonds, cut, desc(price)) #by two or more variables
```

## mutate
Besides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. That’s the job of mutate().

>- <strong>Arithmetic:</strong> +, -, *, /, ^
>- <strong>Modular:</strong> %/% (integer division), %%  (remainder), x == y * (x %/% y) + (x %% y)
>- <strong>Logs:</strong> log(), log2(), logn()
>- <strong>Offsets:</strong> lead(), lag()
>- <strong>Cumulatives:</strong> cumsum(), cumprod(), cummin(), cummax() See RcppRoll package for more.
>- <strong>Logical:</strong> <, <=, >, >=, !=, ==
>- <strong>Ranking:</strong> min_rank(), row_number(), dense_rank(), percent_rank(),  cume_dist(), ntile()
>- <strong>User defined:</strong> function(){} – should be a vectorised function

## mutate
<strong class="blue2">TIP:</strong> Arithmetic operators are useful in conjunction with aggregate functions, e.g. X/sum(X) gives the proportion, and Y-mean(Y) computes the difference from the mean.  
<strong class="blue2">TIP:</strong> Offsets allows you to compute running differences (e.g. x-lag(x)) or find when values change (X != lag(X)) They are most useful in conjunction with group_by(), but make sure to sort first using arrange().


```{r,eval=FALSE}
mutate(
  diamonds,
  price_p_carat = price / carat,
  diff = price_p_carat - mean(price_p_carat),
  z_score = diff / sd(price_p_carat)
)
```


## summarise
The last key verb is summarise(). It collapses a data frame to a single row. summarise() is not terribly useful unless we pair it with group_by().  

>- <strong class="blue2">TIP:</strong> There are many built in functions so don’t reinvent the wheel.  
>- <strong class="blue2">TIP:</strong> The result of a summary can be used directly in the next step to calculate other statistics.  
>- <strong class="red2">WARNING:</strong> Remember when calculating statistics that the result is not always as you would expect, e.g. mean() returns the straight average not the weighted average. 
>- <strong class="red2">WARNING:</strong> Always check the documentation before using built in functions to know what options there are and what the default options are. It is important to understand exactly what you are calculating.

## summarise
```{r}
summarise(
  diamonds,
  N = n(),
  sum = sum(price),
  ave1 = sum / N,
  SSD = sum( (price - mean(price)) ^2),
  SD = sqrt( SSD / (n() -1) )
)
```

## group_by
summarise() is not terribly useful unless we pair it with group_by(). When you use the dplyr verbs on a grouped data frame they’ll be automatically applied “by group”.

<strong class="blue2">TIP:</strong> group_by() is useful when calculating statistics per group. These statistics can then be easily compared.  

<strong class="blue2">TIP:</strong> Complicated models can also be built and then run on a group-by-group basis.  

<strong class="red2">WARNING:</strong> When using group_by() with summarise() the groups get unwound after the summarise(). That means if you group by Var1 and Var2 after doing a summary the data frame will only be grouped by Var1. Thus the order of the variables used in the  group_by() matter.

## group_by
```{r}
diamonds_grouped <- group_by(diamonds,cut)
summarise(
  diamonds_grouped,
  N = n(),
  average = mean(price),
  SD = sd(price)
)
```

## %>% (pipe)
%>% is used to string functions together. This makes writing a set of logic clear and condensed.

```{r,  include=FALSE}
library(plotly)
pal_deloitte<-c("#86BC25", "#C4D600",  "#43B02A",	"#046A38", 	"#2C5234","#0097A9","#62B5E5","#00A3E0","#0076A8","#012169")
pal_deloitte2<-c("#DDEFE8",	"#9DD4CF", 	"#6FC2B4","#00ABAB","#0097A9","#007680","#004F59")
```
```{r,eval=FALSE}
diamonds%>%
  group_by(color, clarity)%>%
  summarise(n = n())%>%
  mutate(prop=n/sum(n))%>%
  plot_ly( x = ~color, y = ~prop, color= ~clarity,type = "bar",colors = pal_deloitte)%>%
  layout(barmode = "stack")
```

## %>% (pipe) {.flexbox .vcenter}
```{r echo=FALSE}
diamonds%>%
  group_by(color, clarity)%>%
  summarise(n = n())%>%
  mutate(prop=n/sum(n))%>%
  plot_ly( x = ~color, y = ~prop, color= ~clarity,type = "bar",colors = pal_deloitte)%>%
  layout(barmode = "stack")
```

## Exercise
Using the transition data calculate the transistion matrix for each segment. A transition rate is defined as:
$$p_{ij}=Pr({X_{t+1}=j|X_{t}=i})$$
$$p_{ij}=\frac{\sum_n balance_{n,t} \times I(X_{n,t+1}=j|X_{n,t}=i)}{\sum_n balance_{n,t} \times I(X_{n,t}=i)}$$
<strong class="yellow2">HINT:</strong> Make sure that your rows sum up to one  



